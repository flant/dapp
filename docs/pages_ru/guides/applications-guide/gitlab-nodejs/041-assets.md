TODO: надо разобрать и рерайтнуть вот это всё ниже. Или вообще вынести в сделать потом во всех статьях.

Обычно используется несколько режимов для удобной разработки, но конечный вариант который идёт в kubernetes (в любое из окружений) всегда сборка как в production. Остальная отладка производится только локально. Почему необходимо чтобы сборка всегда была одинаковой?

Потому что наш docker image между окружениями должен быть неизменяемым. Создано это для того чтобы мы всегда были уверены в нашей сборке, т.е. образ оттестированный на stage окружении должен попадать в production точно таким же. Для всего остального мира наше приложение должно быть чёрным ящиком, которое лишь может принимать параметры.

Если же вам необходимо иметь внутри вашего кода ссылки или любые други изменяемые между окружениями объекты, то сделать это можно несколькими способами:

1. Мы можем динамически в зависимости от окружение монтировать в контейнер с нашим приложением json с нужными параметрами. Для этого нам нужно создать объект configmap в .helm/templates.

**10-app-config.yaml**

```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Chart.Name }}-config
data:
  config.json: |-
   {
    "domain": "{{ pluck .Values.global.env .Values.domain | first }}",
    "loginUrl": "{{ pluck .Values.global.env .Values.loginUrl | first }}"
   }
```


А затем примонтировать к нашему приложению в то место где мы могли получать его по запросу от клиента: \
Код из 01-app.yaml:


```yaml
       volumeMounts:
          - name: app-config
            mountPath: /app/dist/config.json
            subPath: config.json
      volumes:
        - name: app-config
          configMap:
            name: {{ .Chart.Name }}-config
```
После того как конфиг окажется внутри вашего приложения вы сможете обращатся к нему как обычно.

2. И второй вариант перед запуском приложения получать конфиги из внешнего ресурса,например из [consul](https://www.consul.io/). Подробно не будем расписывать данный вариант, так как он достоин отдельной главы. Дадим лишь два совета: 

*   Можно запускать его перед запуском приложения добавив в `command: ["node","/app/src/js/server.js"] `его запуск через `&&` как в синтаксисе любого shell языка, прямо в манифесте описывающем приложение:
```yaml
command: 
- /usr/bin/bash
- -c
- --
- "consul kv get app/config/urls && node /app/src/js/server.js"]
```


*   Либо добавив его запуск в [init-container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) и подключив между инит контейнером и основным контейнером общий [volume](https://kubernetes.io/docs/concepts/storage/volumes/), это означает что просто нужно смонтировать volume в оба контейнера. Например [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir). Тем самым консул отработав в инит контейнере, сохранит конфиг в наш volume, а приложение из основного контейнера просто заберёт этот конфиг. 
