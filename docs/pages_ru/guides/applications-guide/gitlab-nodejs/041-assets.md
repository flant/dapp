## Важность неизменяемой сборки

Довольно часто возникают такие ситуации, когда разработчики на NodeJs c помощью переменных или конфигов создают несколько режимов сборки приложения. И в зависимости от этих переменных их приложение может при сборке по разному генерировать статичные объекты, например ссылки внутри веб страниц. Такой подход безусловно удобен для локальной разработки, но мы крайне не рекомендуем использовать его внутри вашего CI/CD. Образ поподающий в кластер, в любое из окружений, должен быть абсолютно одинаковым. И мы знаем что у некоторых людей может возникнуть вопрос "Почему?".

Потому что наш docker image между окружениями должен быть неизменяемым. Создано это для того чтобы мы всегда были уверены в нашей сборке, т.е. образ оттестированный на stage окружении должен попадать в production точно таким же. Для всего остального мира наше приложение должно быть чёрным ящиком, которое может лишь принимать параметры.

Если же вам необходимо иметь внутри вашего кода ссылки или любые други изменяемые между окружениями объекты, то сделать это можно несколькими способами:

1. Мы можем динамически в зависимости от окружение монтировать в контейнер с нашим приложением json с нужными параметрами. Для этого нам нужно создать объект configmap в .helm/templates.

**10-app-config.yaml**

{% raw %}
```yaml
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Chart.Name }}-config
data:
  config.json: |-
   {
    "domain": "{{ pluck .Values.global.env .Values.domain | first }}",
    "loginUrl": "{{ pluck .Values.global.env .Values.loginUrl | first }}"
   }
```
{% endraw %}


А затем примонтировать к нашему приложению в то место где мы могли получать его по запросу от клиента: \
Код из 01-app.yaml:


{% raw %}
```yaml
       volumeMounts:
          - name: app-config
            mountPath: /app/dist/config.json
            subPath: config.json
      volumes:
        - name: app-config
          configMap:
            name: {{ .Chart.Name }}-config
```
{% endraw %}
После того как конфиг окажется внутри вашего приложения вы сможете обращатся к нему как обычно.

2. И второй вариант перед запуском приложения получать конфиги из внешнего ресурса,например из [consul](https://www.consul.io/). Подробно не будем расписывать данный вариант, так как он достоин отдельной главы. Дадим лишь два совета: 

*   Можно запускать его перед запуском приложения добавив в `command: ["node","/app/src/js/server.js"] `его запуск через `&&` как в синтаксисе любого shell языка, прямо в манифесте описывающем приложение:
{% raw %}
```yaml
command: 
- /usr/bin/bash
- -c
- --
- "consul kv get app/config/urls && node /app/src/js/server.js"]
```
{% endraw %}


*   Либо добавив его запуск в [init-container](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/) и подключив между инит контейнером и основным контейнером общий [volume](https://kubernetes.io/docs/concepts/storage/volumes/), это означает что просто нужно смонтировать volume в оба контейнера. Например [emptyDir](https://kubernetes.io/docs/concepts/storage/volumes/#emptydir). Тем самым консул отработав в инит контейнере, сохранит конфиг в наш volume, а приложение из основного контейнера просто заберёт этот конфиг. 
