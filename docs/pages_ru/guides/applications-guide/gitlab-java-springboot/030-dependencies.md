---
title: Подключение зависимостей
sidebar: applications-guide
permalink: documentation/guides/applications-guide/template/030-dependencies.html
layout: guide
---

{% filesused title="Файлы, упомянутые в главе" %}
- werf.yaml
{% endfilesused %}



Werf подразумевает, что лучшей практикой будет разделить сборочный процесс на этапы, каждый с четкими функциями и своим назначением. Каждый такой этап соответствует промежуточному образу, подобно слоям в Docker. В werf такой этап называется стадией, и конечный образ в итоге состоит из набора собранных стадий. Все стадии хранятся в хранилище стадий, которое можно рассматривать как кэш сборки приложения, хотя по сути это скорее часть контекста сборки.

Стадии — это этапы сборочного процесса, кирпичи, из которых в итоге собирается конечный образ. Стадия собирается из группы сборочных инструкций, указанных в конфигурации. Причем группировка этих инструкций не случайна, имеет определенную логику и учитывает условия и правила сборки. С каждой стадией связан конкретный Docker-образ. Подробнее о том, какие стадии для чего предполагаются можно посмотреть в [документации](https://ru.werf.io/documentation/reference/stages_and_images.html).

Werf предлагает использовать для стадий следующую стратегию:

*   использовать стадию beforeInstall для инсталляции системных пакетов;
*   использовать стадию install для инсталляции системных зависимостей и зависимостей приложения;
*   использовать стадию beforeSetup для настройки системных параметров и установки приложения;
*   использовать стадию setup для настройки приложения.

Подробно про стадии описано в [документации](https://ru.werf.io/documentation/configuration/stapel_image/assembly_instructions.html).

В Java, в частности в spring, в качестве менеджера зависимостей может использоваться maven, gradle. Мы будем, как и ранее использовать maven, но для gradle кроме самих команд, логика сборки не поменяется. Мы уже описывали ранее его использование в файле `werf.yaml` но сейчас оптимизируем его использование.

<a name="dependencies-implementation" />

## Подключение менеджера зависимостей

В maven используется pom.xml в качестве файла проекта где, помимо мета-информации, описываются зависимости. Вот так мы к нему обращались когда собирали приложение ранее:

```yaml
    shell: |
      mvn -B -f pom.xml package dependency:resolve
```

[werf.yaml](gitlab-java-springboot-files/00-demo/werf.yaml:20)

Однако, если оставить всё так — стадия `beforeInstall` не будет запускаться при изменении pom.xml и любого кода в src. Подобная зависимость пользовательской стадии от изменений [указывается с помощью параметра git.stageDependencies](https://ru.werf.io/documentation/configuration/stapel_image/assembly_instructions.html#%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C-%D0%BE%D1%82-%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9-%D0%B2-git-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B8):

```yaml
git:
- add: /
  to: /app
  stageDependencies:
    setup:
    - pom.xml
    - src
```

Теперь при изменении файла pom.xml или любого из файлов в `src` стадия `setup` будет запущена заново.
Почитать о том как формируется pom.xml вручную можно [здесь](https://maven.apache.org/guides/getting-started/maven-in-five-minutes.html). В нашем случае, для spring мы снова воспользуемся веб-интерфейсом [https://start.spring.io/](https://start.spring.io/), который использовали для формирования hello-world приложения. Плюсом этого метода безусловано является его быстрота, возможность избежать глупых ошибок при написании pom.xml.

<a name="dependencies-optimization" />

## Оптимизация сборки

В случае с spring даже в пустом проекте сборщику нужно скачать приличное количество файлов, которое происходит не за нулевое время. И скачивать эти файлы раз за разом выглядит нецелесообразным, тем более что maven (и gradle) позволяет этот кеш переиспользовать при локальной сборке.
Для оптимизации скорости сборки у werf есть несколько механизмов.
Рассмотрим сначала возможность переиспользовать кеш, который скачивает maven в .m2/repository. В werf есть механизм переиспользования так называемого build_dir между сборками в одном проекте. С помощью него и будем пробрасывать кеш в сборочные контейнеры.

Для этого в werf служит директива mount:


```yaml
...
mount:
- from: build_dir
  to: /root/.m2/repository
...
```
[werf.yaml](gitlab-java-springboot-files/01-demo-optimization/werf.yaml:14-16)

Как упоминалось выше - werf кеширует успешные стадии деплоя, что существенно ускоряет сборки. А maven позволяет отдельно выполнить команды resolve зависимостей и выполнять сборку приложения. Вынесем resolve зависимостей на отдельную - предыдущую - стадию. В этом случае, при изменении только кода, а не pom.xml werf увидит слой с зависимостями не поменялся и возьмет его из кеша, а затем уже проведет сборку приложения используя измененный код. Вынесем скачивание локального репозитория в стадию beforeSetup. И настроим стадию setup на сборку в случае изменений чего-либо в папке src, где и лежит сам код:

```yaml
...
ansible:
  beforeSetup:
  - name: dependency resolve
    shell: |
      mvn -B -f pom.xml dependency:resolve
    args:
      chdir: /app
      executable: /bin/bash
  setup:
  - name: Build jar
    shell: |
      mvn -B -f pom.xml package
    args:
      chdir: /app
      executable: /bin/bash
```

[werf.yaml](gitlab-java-springboot-files/01-demo-optimization/werf.yaml:17-31)

Теперь первая сборка - без кешей - будет сравнительно долгой. Будут скачиваться репозитории maven, описанные в pom.xml, затем из кода в src будет собираться приложение. Напомню о механизмах отладки на этом этапе -

```shell
--introspect-before-error
--introspect-error
```

И в случае проблем мы сможем попасть внутрь контейнера и выполнить команды сборки вручную.

На этом этапе у нас получилось оптимизировать скорость сборки - кеш каждый раз не скачивается, стадия не перезапускается при изменении только кода. Однако базовый образ maven:3-jdk-8, который мы использовали для сборки, достаточно тяжелый, нет смысла запускать код со всеми сборочными зависимостями в kubernetes. 
Будем запускать используя достаточно легкий openjdk:8-jdk-alpine. Но нам все еще нужно собирать jar в образе с maven. Для реализации этого решения воспользуемся [артефактом](https://werf.io/documentation/configuration/stapel_artifact.html). По сути это то же самое что и image в директивах werf.yaml, только временный. Он не пушится в registry.
Переименуем image в artifact и назовем его build. Результатом его работы является собранный jar - именно его мы и импортируем в image с alpine-openjdk который опишем в этом же werf.yaml после "---", которые разделяют image. Назовем его spring и уже его пушнем в registry для последующего запуска в кластере.

```yaml
---
image: hello
from: openjdk:8-jdk-alpine
import:
- artifact: build
  add: /app/target/*.jar
  to: /app/demo.jar
  after: setup
```

[werf.yaml](gitlab-java-springboot-files/01-demo-optimization/werf.yaml:32-39)

Для импорта между image и artifact служит директива import. Из /app/target в сборочном артефакте импортируем собранный jar-файл в папку /app в image spring. Единственное что следует еще поправить - это версию собираемого jar в [pom.xml](01-demo-optimization/pom.xml:14). Пропишем её 1.0, чтобы имя итогового jar-файла получось предсказуемым - demo-1.0.jar. 

